// Generated By:CSharpCC: Do not edit this line. MiniCSharpParser.cs
        namespace ModernCompilerImplementation.Chapter2.CSharpCC.Lib {

        using System;

        class MiniCSharpParser : MiniCSharpParserConstants {

   public void Start() {
    trace_call("Start");
    try {
      while (true) {
        switch ((cc_ntKind==-1)?cc_ntk():cc_ntKind) {
        case IF:
        case ID:
        case NUM:
        case REAL:
          ;
          break;
        default:
          cc_la1[0] = cc_gen;
          goto label_1;
        }
        switch ((cc_ntKind==-1)?cc_ntk():cc_ntKind) {
        case IF:
          cc_consume_token(IF);
          break;
        case ID:
          cc_consume_token(ID);
          break;
        case NUM:
          cc_consume_token(NUM);
          break;
        case REAL:
          cc_consume_token(REAL);
          break;
        default:
          cc_la1[1] = cc_gen;
          cc_consume_token(-1);
          throw new ParseException();
        }
      }label_1:;
      
    } finally {
      trace_return("Start");
    }
  }

  /** Generated Token Manager. */
  public  MiniCSharpParserTokenManager tokenSource;
  SimpleCharStream cc_inputStream;
  /// <summary>Current token.</summary>
  public Token token;
  /// <summary> Next token.</summary>
  public Token cc_nt;
  private int cc_ntKind;
  private int cc_gen;
   private readonly int[] cc_la1 = new int[2];
  static private int[] cc_la1_0;
  static MiniCSharpParser() { 
      cc_la1_init_0();
   }
   private static void cc_la1_init_0() {
      cc_la1_0 = new int[] {58,58,};
   }

  /// Constructor with Stream.
  public MiniCSharpParser(System.IO.Stream stream)
     : this(stream, null) {
  }
  /// Constructor with Stream and supplied encoding
  public MiniCSharpParser(System.IO.Stream stream, System.Text.Encoding encoding) {
    cc_inputStream = new SimpleCharStream(stream, encoding, 1, 1);
    tokenSource = new MiniCSharpParserTokenManager(cc_inputStream);
    token = new Token();
    cc_ntKind = -1;
    cc_gen = 0;
    for (int i = 0; i < 2; i++) cc_la1[i] = -1;
  }

  /// Reinitialise.
  public void ReInit(System.IO.Stream stream) {
     ReInit(stream, null);
  }
  /// Reinitialise.
  public void ReInit(System.IO.Stream stream, System.Text.Encoding encoding) {
   cc_inputStream.ReInit(stream, encoding, 1, 1);
    tokenSource.ReInit(cc_inputStream);
    token = new Token();
    cc_ntKind = -1;
    cc_gen = 0;
    for (int i = 0; i < 2; i++) cc_la1[i] = -1;
  }

  /// Constructor.
  public MiniCSharpParser(System.IO.TextReader reader) {
    cc_inputStream = new SimpleCharStream(reader, 1, 1);
    tokenSource = new MiniCSharpParserTokenManager(cc_inputStream);
    token = new Token();
    cc_ntKind = -1;
    cc_gen = 0;
    for (int i = 0; i < 2; i++) cc_la1[i] = -1;
  }

  /// Reinitialise.
  public void ReInit(System.IO.TextReader reader) {
    cc_inputStream.ReInit(reader, 1, 1);
    tokenSource.ReInit(cc_inputStream);
    token = new Token();
    cc_ntKind = -1;
    cc_gen = 0;
    for (int i = 0; i < 2; i++) cc_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public MiniCSharpParser(MiniCSharpParserTokenManager tm) {
    tokenSource = tm;
    token = new Token();
    cc_ntKind = -1;
    cc_gen = 0;
    for (int i = 0; i < 2; i++) cc_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MiniCSharpParserTokenManager tm) {
    tokenSource = tm;
    token = new Token();
    cc_ntKind = -1;
    cc_gen = 0;
    for (int i = 0; i < 2; i++) cc_la1[i] = -1;
  }

  private Token cc_consume_token(int kind) {
    Token oldToken;
    if ((oldToken = token).Next != null) token = token.Next;
    else token = token.Next = tokenSource.GetNextToken();
    cc_ntKind = -1;
    if (token.Kind == kind) {
      cc_gen++;
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    cc_kind = kind;
    throw GenerateParseException();
  }


/** Get the next Token. */
   public Token GetNextToken() {
    if (token.Next != null) token = token.Next;
    else token = token.Next = tokenSource.GetNextToken();
    cc_ntKind = -1;
    cc_gen++;
      trace_token(token, " (in GetNextToken)");
    return token;
  }

/** Get the specific Token. */
   public Token GetToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.Next != null) t = t.Next;
      else t = t.Next = tokenSource.GetNextToken();
    }
    return t;
  }

  private int cc_ntk() {
    if ((cc_nt=token.Next) == null)
      return (cc_ntKind = (token.Next = tokenSource.GetNextToken()).Kind);
    else
      return (cc_ntKind = cc_nt.Kind);
  }

  private System.Collections.Generic.IList<int[]> cc_expentries = new System.Collections.Generic.List<int[]>();
  private int[] cc_expentry;
  private int cc_kind = -1;

  /** Generate ParseException. */
  public ParseException GenerateParseException() {
    cc_expentries.Clear();
    bool[] la1tokens = new bool[11];
    if (cc_kind >= 0) {
      la1tokens[cc_kind] = true;
      cc_kind = -1;
    }
    for (int i = 0; i < 2; i++) {
      if (cc_la1[i] == cc_gen) {
        for (int j = 0; j < 32; j++) {
          if ((cc_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 11; i++) {
      if (la1tokens[i]) {
        cc_expentry = new int[1];
        cc_expentry[0] = i;
        cc_expentries.Add(cc_expentry);
      }
    }
    int[][] exptokseq = new int[cc_expentries.Count][];
    for (int i = 0; i < cc_expentries.Count; i++) {
      exptokseq[i] = cc_expentries[i];
    }
    return new ParseException(token, exptokseq, TokenImage);
  }

  private int trace_indent = 0;
  private bool trace_enabled = true;

/** Enable tracing. */
   public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
   public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(string s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { Console.Out.Write(" "); }
      Console.Out.WriteLine("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(string s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { Console.Out.Write(" "); }
      Console.Out.WriteLine("Return: " + s);
    }
  }

  private void trace_token(Token t, string loc) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { Console.Out.Write(" "); }
      Console.Out.Write("Consumed token: <" + TokenImage[t.Kind]);
      if (t.Kind != 0 && !TokenImage[t.Kind].Equals("\"" + t.Image + "\"")) {
        Console.Out.Write(": \"" + t.Image + "\"");
      }
      Console.Out.WriteLine(" at line " + t.BeginLine + " column " + t.BeginColumn + ">" + loc);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { Console.Out.Write(" "); }
      Console.Out.Write("Visited token: <" + TokenImage[t1.Kind]);
      if (t1.Kind != 0 && !TokenImage[t1.Kind].Equals("\"" + t1.Image + "\"")) {
        Console.Out.Write(": \"" + t1.Image + "\"");
      }
      Console.Out.WriteLine(" at line " + t1.BeginLine + " column " + t1.BeginColumn + ">; Expected token: <" + TokenImage[t2] + ">");
    }
  }

        }
}
