/* Generated By:CSharpCC: Do not edit this line. MiniCSharpParserTokenManager.cs */
namespace ModernCompilerImplementation.Chapter2.CSharpCC.Lib {

using System;

// Token Manager.
public class MiniCSharpParserTokenManager : MiniCSharpParserConstants {

  // Debug output.
  public  System.IO.TextWriter debugStream = Console.Out;
  // Set debug output.
  public  void SetDebugStream(System.IO.TextWriter ds) { debugStream = ds; }
private int ccStopStringLiteralDfa_0(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 2L) != 0L)
         {
            ccMatchedKind = 3;
            return 1;
         }
         return -1;
      default :
         return -1;
   }
}
private int ccStartNfa_0(int pos, long active0)
{
   return ccMoveNfa_0(ccStopStringLiteralDfa_0(pos, active0), pos + 1);
}
private int ccStopAtPos(int pos, int kind)
{
   ccMatchedKind = kind;
   ccMatchedPos = pos;
   return pos + 1;
}
private int ccMoveStringLiteralDfa0_0(){
   switch((int)curChar)   {
      case 105:
         return ccMoveStringLiteralDfa1_0(2L);
      default :
         return ccMoveNfa_0(0, 0);
   }
}
private int ccMoveStringLiteralDfa1_0(long active0){
   try { curChar = inputStream.ReadChar(); }
   catch(System.IO.IOException) {
      ccStopStringLiteralDfa_0(0, active0);
      return 1;
   }
   switch((int)curChar)   {
      case 102:
         if ((active0 & 2L) != 0L)
            return ccStartNfaWithStates_0(1, 1, 1);
         break;
      default :
         break;
   }
   return ccStartNfa_0(0, active0);
}
private int ccStartNfaWithStates_0(int pos, int kind, int state)
{
   ccMatchedKind = kind;
   ccMatchedPos = pos;
   try { curChar = inputStream.ReadChar(); }
   catch(System.IO.IOException e) { return pos + 1; }
   return ccMoveNfa_0(state, pos + 1);
}
static readonly long[] ccBitVec0 = {
   0L, 0L, -1L, -1L
};
private  int ccMoveNfa_0(int startState, int curPos)
{
   int startsAt = 0;
   ccNewStateCnt = 16;
   int i = 1;
   ccStateSet[0] = startState;
   int kind = Int32.MaxValue;
   for (;;)
   {
      if (++ccRound == Int32.MaxValue)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         do
         {
            switch(ccStateSet[--i])
            {
               case 0:
                  if ((287948901175001088L & l) != 0L)
                  {
                     if (kind > 2)
                        kind = 2;
                     ccCheckNAddStates(0, 4);
                  }
                  else if (curChar == 45)
                     ccStateSet[ccNewStateCnt++] = 4;
                  else if (curChar == 46)
                     ccCheckNAdd(3);
                  break;
               case 1:
                  if ((287948901175001088L & l) == 0L)
                     break;
                  if (kind > 3)
                     kind = 3;
                  ccStateSet[ccNewStateCnt++] = 1;
                  break;
               case 2:
                  if (curChar == 46)
                     ccCheckNAdd(3);
                  break;
               case 3:
                  if ((287948901175001088L & l) == 0L)
                     break;
                  if (kind > 5)
                     kind = 5;
                  ccCheckNAdd(3);
                  break;
               case 4:
                  if (curChar == 45)
                     ccCheckNAddStates(5, 7);
                  break;
               case 5:
                  if ((-9217L & l) != 0L)
                     ccCheckNAddStates(5, 7);
                  break;
               case 6:
                  if ((9216L & l) != 0L && kind > 6)
                     kind = 6;
                  break;
               case 7:
                  if (curChar == 10 && kind > 6)
                     kind = 6;
                  break;
               case 8:
                  if (curChar == 13)
                     ccStateSet[ccNewStateCnt++] = 7;
                  break;
               case 9:
                  if (curChar == 45)
                     ccStateSet[ccNewStateCnt++] = 4;
                  break;
               case 10:
                  if ((287948901175001088L & l) == 0L)
                     break;
                  if (kind > 2)
                     kind = 2;
                  ccCheckNAddStates(0, 4);
                  break;
               case 11:
                  if ((287948901175001088L & l) == 0L)
                     break;
                  if (kind > 4)
                     kind = 4;
                  ccCheckNAdd(11);
                  break;
               case 12:
                  if ((287948901175001088L & l) != 0L)
                     ccCheckNAddTwoStates(12, 13);
                  break;
               case 13:
                  if (curChar != 46)
                     break;
                  if (kind > 5)
                     kind = 5;
                  ccCheckNAdd(14);
                  break;
               case 14:
                  if ((287948901175001088L & l) == 0L)
                     break;
                  if (kind > 5)
                     kind = 5;
                  ccCheckNAdd(14);
                  break;
               case 15:
                  if ((287948901175001088L & l) != 0L)
                     ccCheckNAddTwoStates(15, 2);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 63);
         do
         {
            switch(ccStateSet[--i])
            {
               case 0:
               case 1:
                  if ((576460743713488896L & l) == 0L)
                     break;
                  if (kind > 3)
                     kind = 3;
                  ccCheckNAdd(1);
                  break;
               case 5:
                  if ((-1L & l) != 0L)
                     ccAddStates(5, 7);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 63);
         do
         {
            switch(ccStateSet[--i])
            {
               case 5:
                  if ((ccBitVec0[i2] & l2) != 0L)
                     ccAddStates(5, 7);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != Int32.MaxValue)
      {
         ccMatchedKind = kind;
         ccMatchedPos = curPos;
         kind = Int32.MaxValue;
      }
      ++curPos;
      if ((i = ccNewStateCnt) == (startsAt = 16 - (ccNewStateCnt = startsAt)))
         return curPos;
      try { curChar = inputStream.ReadChar(); }
      catch(System.IO.IOException) { return curPos; }
   }
}
static readonly int[] ccNextStates = {
   11, 12, 13, 15, 2, 5, 6, 8, 
};

// Token literal values.
public static readonly string[] ccStrLiteralImages = {
"", "if", null, null, null, null, null, null, null, null, null, };

// Lexer state names.
public static readonly string[] lexStateNames = {
   "DEFAULT"
};
static readonly long[] ccToToken = {   
63L, };
static readonly long[] ccToSkip = {   
1984L, };
internal SimpleCharStream inputStream;
private readonly int[] ccRounds = new int[16];
private readonly int[] ccStateSet = new int[32];
protected char curChar;
// Constructor.
public MiniCSharpParserTokenManager (SimpleCharStream stream){
   if (SimpleCharStream.staticFlag)
      throw new InvalidOperationException("ERROR: Cannot use a static ICharStream class with a non-static lexical analyzer.");
   inputStream = stream;
}

// Constructor.
public MiniCSharpParserTokenManager (SimpleCharStream stream, int lexState)
   : this(stream) {
   SwitchTo(lexState);
}

/** Reinitialise parser. */
public void ReInit(SimpleCharStream stream){
   ccMatchedPos = ccNewStateCnt = 0;
   curLexState = defaultLexState;
   inputStream = stream;
   ReInitRounds();
}
private void ReInitRounds(){
   int i;
   ccRound = -2147483647;
   for (i = 16; i-- > 0;)
      ccRounds[i] = Int32.MinValue;
}

// Reinitialise parser.
public void ReInit(SimpleCharStream stream, int lexState){
   ReInit(stream);
   SwitchTo(lexState);
}

// Switch to specified lex state.
public void SwitchTo(int lexState){
   if (lexState >= 1 || lexState < 0)
      throw new TokenManagerError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenManagerError.INVALID_LEXICAL_STATE);
   else
      curLexState = lexState;
}

internal Token ccFillToken(){
   Token t;
   string curTokenImage;
   int beginLine;
   int endLine;
   int beginColumn;
   int endColumn;
   string im = ccStrLiteralImages[ccMatchedKind];
   curTokenImage = (im == null) ? inputStream.GetImage() : im;
   beginLine = inputStream.BeginLine;
   beginColumn = inputStream.BeginColumn;
   endLine = inputStream.EndLine;
   endColumn = inputStream.EndColumn;
   t = Token.NewToken(ccMatchedKind);
   t.Kind = ccMatchedKind;
   t.Image = curTokenImage;

   t.BeginLine = beginLine;
   t.EndLine = endLine;
   t.BeginColumn = beginColumn;
   t.EndColumn = endColumn;

   return t;
}

int curLexState = 0;
int defaultLexState = 0;
int ccNewStateCnt;
int ccRound;
int ccMatchedPos;
int ccMatchedKind;

// Get the next Token.
public Token GetNextToken() 
{
  Token matchedToken;
  int curPos = 0;

  while (true) {
   try {
      curChar = inputStream.BeginToken();
   }  catch(System.IO.IOException e) {
      ccMatchedKind = 0;
      matchedToken = ccFillToken();
      return matchedToken;
   }

   try { inputStream.Backup(0);
      while (curChar <= 32 && (4294977024L & (1L << curChar)) != 0L)
         curChar = inputStream.BeginToken();
   }
   catch (System.IO.IOException) { goto EOFLoop; }
   ccMatchedKind = Int32.MaxValue;
   ccMatchedPos = 0;
   curPos = ccMoveStringLiteralDfa0_0();
   if (ccMatchedKind != Int32.MaxValue)
   {
      if (ccMatchedPos + 1 < curPos)
         inputStream.Backup(curPos - ccMatchedPos - 1);
      if ((ccToToken[ccMatchedKind >> 6] & (1L << (ccMatchedKind & 077))) != 0L)
      {
         matchedToken = ccFillToken();
         return matchedToken;
      }
      else
      {
         goto EOFLoop;
      }
   }
   int errorLine = inputStream.EndLine;
   int errorColumn = inputStream.EndColumn;
   string errorAfter = null;
   bool EOFSeen = false;
   try { inputStream.ReadChar(); inputStream.Backup(1); }
   catch (System.IO.IOException) {
      EOFSeen = true;
      errorAfter = curPos <= 1 ? "" : inputStream.GetImage();
      if (curChar == '\n' || curChar == '\r') {
         errorLine++;
         errorColumn = 0;
      }
      else
         errorColumn++;
   }
   if (!EOFSeen) {
      inputStream.Backup(1);
      errorAfter = curPos <= 1 ? "" : inputStream.GetImage();
   }
   throw new TokenManagerError(EOFSeen, curLexState, errorLine, errorColumn, errorAfter, curChar, TokenManagerError.LEXICAL_ERROR);
  EOFLoop: ;
  }
}

private void ccCheckNAdd(int state)
{
   if (ccRounds[state] != ccRound)
   {
      ccStateSet[ccNewStateCnt++] = state;
      ccRounds[state] = ccRound;
   }
}
private  void ccAddStates(int start, int end)
{
   do {
      ccStateSet[ccNewStateCnt++] = ccNextStates[start];
   } while (start++ != end);
}
private  void ccCheckNAddTwoStates(int state1, int state2)
{
   ccCheckNAdd(state1);
   ccCheckNAdd(state2);
}

private void ccCheckNAddStates(int start, int end)
{
   do {
      ccCheckNAdd(ccNextStates[start]);
   } while (start++ != end);
}

}
}
